---
title: Padr√£o DAO
description: Programa√ß√£o em Java para Web
layout: course
type: classnote
date: 2017-10-02 00:00
---

_As implementa√ß√µes mostradas nesse documento fazem uso da biblioteca [sql2o]_.

* TOC
{:toc}

# Como os dados s√£o acessados?

Mesmo usando bibliotecas como [sql2o] para facilitar a escrita de c√≥digo de acesso ao banco de dados, ainda √©
necess√°rio o uso de abstra√ß√£o para termos um c√≥digo mais organizado e menos propenso a erros.

[sql2o]: 13.html

---

Ao criar telas de cadastro de livros, o desenvolvedor poderia fazer os seguintes questionamentos:

- Em qual <u>tabela</u> os livros est√£o sendo inseridos?
- Qual coluna √© a <u>chave prim√°ria</u>?
- Existem <u>chaves estrangeiras</u>? Quais?

O desenvolvedor deveria precisar de tudo isso para proceder com o trabalho?

# Data Access Object (DAO)

O padr√£o DAO √©, provavelmente, o mais utilizado para acesso a bancos de dados em linguagens de programa√ß√£o orientada a
objetos. Em portugu√™s, significa _Objeto de Acesso a Dados_.

A ideia √© oferecer uma ou mais classes com m√©todos amig√°veis para adicionar, modificar e excluir dados, sem que o
desenvolvedor precise saber detalhes do esquema f√≠sico dos dados.

Engana-se quem acha que isso √© relevante somente para projetos onde existe uma equipe de desenvolvedores, cada um com
uma responsabilidade. Mesmo em "euquipes", com apenas um desenvolvedor faz-tudo, a aplica√ß√£o de DAO √© muito ben√©fica.

## C√≥digo desorganizado üôÅ

Observe, a seguir, o m√©todo `doPost()` de um servlet que tem como objetivo a inser√ß√£o de livros no banco de dados:

{: data-caption="Sem usar DAO"}
```java
protected void doPost(HttpServletRequest request,
                      HttpServletResponse response) throws IOException {
    // Par√¢metros obtidos do usu√°rio
    String paramTitulo = request.getParameter("titulo");
    String paramAutor  = request.getParameter("autor");
    int paramEdicao    = Integer.parseInt(request.getParameter("edicao"));

    // Query de inser√ß√£o
    String query = "INSERT INTO Livros (titulo, autor, edicao) " +
                   "VALUES (:titulo, :autor, :edicao)";

    // Executa query e avalia a resposta
    try (Connection con = sql2o.open()) {
        con.createQuery(query)
            .addParameter("titulo", paramTitulo)
            .addParameter("autor", paramAutor)
            .addParameter("edicao", paramEdicao)
            .executeUpdate();

        // N√∫mero de linhas alteradas, se n√£o √© maior que 0, houve erros...
        int result = con.getResult();
        if (result > 0) {
            response.sendRedirect(request.getRequestURI() + "?adicionado=true");
        } else {
            response.sendError(400, "Erro inesperado ao tentar inserir");
        }
    }
}
```

## C√≥digo mais organizado üòÄ

Agora veja o mesmo m√©todo com o acesso ao banco de dados abstra√≠da:

{: data-caption="Usando DAO: c√≥digo muito mais simples!"}
```java
protected void doPost(HttpServletRequest request,
                      HttpServletResponse response) throws IOException {
    // Par√¢metros obtidos do usu√°rio como atributos
    Livro livro = new Livro();
    livro.setTitulo(request.getParameter("titulo"));
    livro.setAutor(request.getParameter("autor"));
    livro.setEdicao(Integer.parseInt(request.getParameter("edicao")));

    // Objeto de acesso a dados
    LivroDao dao = new LivroDao();

    // Chama o m√©todo de adicionar livro
    boolean ok = dao.adicionar(livro);
    
    // Mostra mensagem de sucesso ou de falha da opera√ß√£o
    if (ok) {
        response.sendRedirect(request.getRequestURI() + "?adicionado=true");
    } else {
        response.sendError(400, "Erro inesperado ao tentar inserir");
    }
}
```

No c√≥digo acima, a classe `Livro` √© um [POJO] e a classe `LivroDao` mant√©m um c√≥digo de acesso a dados que poderia ser
implementada da seguinte forma:

```java
public class LivroDao {

    public boolean adicionar(Livro livro) {
        String query = "INSERT INTO Livros (titulo, autor, edicao) " +
                       "VALUES (:titulo, :autor, :edicao)";

        try (Connection con = sql2o.open()) {
            con.createQuery(query)
                .addParameter("titulo", livro.getTitulo())
                .addParameter("autor", livro.getAutor())
                .addParameter("edicao", livro.getEdicao())
                .executeUpdate();

            // N√∫mero de linhas alteradas, se n√£o √© maior que 0, houve erros...
            return con.getResult() > 0;
        }
    }
    
    // Outros m√©todos, para obter, modificar, excluir livros, etc.
    ...
}
```

Com uma classe separada para acesso a dados, temos o c√≥digo do servlet bem mais direto e objetivo, fazendo apenas o que
√© responsabilidade de um servlet.

Temos, assim, um mandamento para o servlet (ou camada de controller):

> N√£o lidar√°s com o acesso ao banco de dados.

Isso, de uma forma geral, √© o padr√£o DAO!

[POJO]: https://pt.wikipedia.org/wiki/Plain_Old_Java_Objects
{: target="_blank"} 

# Sobre as classes DAO

O padr√£o DAO n√£o estabelece qual dever√° ser os nomes das classes de acesso a dados, bem como a quantidade de classes que
um sistema deve ter.

## Nomes das classes

√â comum que as classes de acesso a dados tenham nomes como:

- `ProdutoDao`
- `ArmarinhoDao`
- `ClienteDao`
- `LojaDao`

Ou seja, um nome relacionado ao neg√≥cio, tal como _Livro_ sufixado por _Dao_, dando a entender que se trata de uma
classe DAO. O uso desse esquema √© t√£o comum que √© recomendado o seguir.

## Quantidade de classes

Imagine que temos um sistema de biblioteca. Quantas classes DAO eu devo ter?

Em geral, existem duas formas de pensar: a primeira seria ter <u>apenas uma</u> classe `BibliotecaDao` para obter,
adicionar, modificar e excluir **livros**, **autores**, **locat√°rios**, **empr√©stimos**, etc. 

A segunda forma seria ter uma classe DAO para cada <u>entidade</u> do banco de dados:

- `LivroDao`
- `AutorDao`
- `LocatarioDao`
- `EmprestimoDao`

# Sobre os m√©todos DAO

Adotando a segunda forma, com classes para cada entidade, a classe `LivroDao` teria a seguinte API:

```java
public class LivroDao {
    public Livro obter(int id) { ... }

    public List<Livro> obterTodos() { ... }
    
    public List<Livro> obterPorTitulo(String titulo) { ... }

    public boolean adicionar(Livro livro) { ... }

    public boolean modificar(Livro livro) { ... }

    public boolean excluir(Livro livro) { ... }
}
```

## M√©todos mais complexos

Supondo que a entidade **Livro** tenha um relacionamento com **Autor**, ent√£o poderia ser interessante a inclus√£o de
outro m√©todo √† classe DAO:

```java
public class LivroDao {
    ...

    /**
     * Autores de um certo livro
     */
    public List<Autor> obterAutores(int livroId) { ... }
}
```

## Perguntas e respostas

**No √∫ltimo exemplo, o m√©todo `obterAutores()` n√£o deveria estar na classe `AutorDao`?**

O retorno do m√©todo √© uma lista de autores, ent√£o poder√≠amos pensar que a classe `AutorDao` √© o melhor lugar para o
colocar. Mas o m√©todo est√° buscando n√£o uma simples lista de autores, mas os autores de um livro em especial. O m√©todo
obt√©m informa√ß√£o realmente √∫til para a entidade **Livro**. Sendo assim, o melhor lugar dele √© realmente em `LivroDao`.

Imagine o contr√°rio, eu quero obter a lista de livros de um certo autor. Entre as classes de acesso `LivroDao` e
`AutorDao` qual √© o melhor local para implementar esse m√©todo?

**Toda classe DAO precisa ter m√©todos para obter, adicionar, modificar e excluir?**

N√£o necessariamente, isso depende do que o software precisa fazer com os dados.

Imagine um sistema de loja em que o gerenciamento de pedidos seja realizada por um sistema de terceiros. Nesse caso, a
classe `PedidoDao` s√≥ precisaria, <u>possivelmente</u>, os m√©todos de buscar.

**Os nomes dos m√©todos importa?**

N√£o, os nomes s√£o <u>normalmente</u> baseados em padr√µes definidos pela equipe de desenvolvimento.

Por exemplo, a classe `LivroDao` poderia ter nomes em ingl√™s para os m√©todos:

```java
public Livro get(int id) { ... }

public List<Livro> getAll() { ... }

public List<Livro> getByTitulo(String titulo) { ... }

public boolean add(Livro livro) { ... }

public boolean update(Livro livro) { ... }

public boolean delete(Livro livro) { ... }

public List<Autor> getAutores(int livroId) { ... }
```

# F√°brica de conex√µes

Quando se aplica o padr√£o DAO, √© tamb√©m comum utilizar um outro chamado de padr√£o _factory_.

O padr√£o _factory_ estabelece que devemos ocultar os detalhes de constru√ß√£o de um objeto. No caso desse assunto, √©
importante que o objeto `Connection` seja constru√≠do sem precisar das informa√ß√µes de acesso ao banco de dados:
 
- a URL de conex√£o;
- o nome de usu√°rio;
- a senha.

---

A f√°brica de conex√µes √© normalmente acessada atrav√©s de um m√©todo `getConnection()` em uma classe chamada `ConnectionFactory`.

Outro nome comum para essa classe √© `Database`, que d√° um significado melhor.

## Uso da f√°brica

Podemos obter uma conex√£o normal:

```java
Connection con = db.getConnection();
```

Ou podemos obter uma transa√ß√£o:

```java
Connection con = db.getConnection("T");
```

Em qualquer dos casos, a conex√£o ainda precisar√° ser fechada, portanto use o `try`:

```java
try (Connection con = db.getConnection()) {
    ...
}
```

## Implementa√ß√£o da f√°brica

{: data-caption="Database.java"}
```java
import org.sql2o.Connection;
import org.sql2o.Sql2o;

public class Database {

    /**
     * Constantes das informa√ß√µes de conex√£o ao SGBD
     */
    private static final String
            JDBC_URL = "jdbc:sqlserver://localhost;databaseName=PROGWEB",
            USER = "sa",
            PASSWORD = "123456";

    /**
     * Inst√¢ncia necess√°ria da biblioteca de acesso a dados
     */
    private final Sql2o sql2o = new Sql2o(JDBC_URL, USER, PASSWORD);

    /**
     * Cria uma conex√£o padr√£o
     */
    public Connection getConnection() {
        return getConnection("");
    }

    /**
     * Cria uma conex√£o com uma dada op√ß√£o
     */
    public Connection getConnection(String option) {
        switch (option) {
            case "T":
                return sql2o.beginTransaction();
            default:
                return sql2o.open();
        }
    }

    //<editor-fold desc="Inst√¢ncia √∫nica da classe (padr√£o singleton)">
    private Database() {
    }

    private static final Database INSTANCE = new Database();

    public static Database getInstance() {
        return INSTANCE;
    }
    //</editor-fold>
}
```

O uso da classe acima seria algo assim:

```java
// Obt√©m inst√¢ncia da f√°brica
Database db = Database.getInstance();

// Cria uma conex√£o com a inst√¢ncia
try (Connection con = db.getConnection()) {
    ...
}
```

## Implementa√ß√£o alternativa

Uma coisa que n√£o d√° para deixar de mostrar √© que a classe `Sql2o` √©, na verdade, uma implementa√ß√£o de f√°brica de
conex√µes m√©todos de acesso diferentes:

| `getConnection()`    | ‚û°Ô∏è | `open()`             |
| `getConnection("T")` | ‚û°Ô∏è | `beginTransaction()` |

Assim, voc√™ pode optar por usar o seguinte _design_,  mais simples, para seu projeto:

{: data-caption="Database.java"}
```java
import org.sql2o.Sql2o;

public class Database extends Sql2o {

    /**
     * Constantes das informa√ß√µes de conex√£o ao SGBD
     */
    private static final String
            JDBC_URL = "jdbc:sqlserver://localhost;databaseName=PROGWEB",
            USER = "sa",
            PASSWORD = "123456";

    //<editor-fold desc="Inst√¢ncia √∫nica da classe (padr√£o singleton)">
    private Database() {
        super(JDBC_URL, USER, PASSWORD);
    }

    private static final Database INSTANCE = new Database();

    public static Database getInstance() {
        return INSTANCE;
    }
    //</editor-fold>
}
```

O uso da f√°brica de conex√µes mudaria ligeiramente para o seguinte c√≥digo:

```java
// Obt√©m inst√¢ncia da f√°brica
Database db = Database.getInstance();

// Cria uma conex√£o com a inst√¢ncia
try (Connection con = db.open()) {
    ...
}
```

Dessa forma, economizamos tempo com o reuso da f√°brica de conex√µes **sql2o** üëç

# Cen√°rio de exemplo

Acesse o [link](15.html) para ver a constru√ß√£o da camada de acesso a dados em um cen√°rio simples.

# Leitura complementar

## Site

[**Bancos de dados e JDBC (Apostila da Caelum)**](https://www.caelum.com.br/apostila-java-web/bancos-de-dados-e-jdbc/)

## Livro

**Cap√≠tulo 15: Trabalhando com Banco de Dados**
 
![](../../assets/images/livros/goncalves2007-jsp.jpg){: width="200" style="border: 1px solid"}
